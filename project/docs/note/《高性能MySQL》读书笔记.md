# 《高性能MySQL》读书笔记

MySQL服务器逻辑架构图

![](C:\Users\yanyh\AppData\Roaming\Typora\typora-user-images\image-20220926094022211.png)	

### 读写锁

**锁的类型：**

读锁 ——共享锁

写锁 ——排他锁

**锁的粒度**

表锁 ——开销最小的锁策略，对整张表加锁会阻塞其他用户线程的读写操作 （表锁在服务器层面使用，会忽略存储引擎的锁机制）

行级锁 ——锁的开销较大，但是可以更大程度的提高读写的并发数。（行级锁实在存储引擎层面实现的，服务器的逻辑层面完全不了解锁是如何实现的）



### 数据库事务

事务就是一组原子性的SQL语句，是一个独立的执行单元。如果其中任意一条语句异常导致无法执行，那么所有的语句都不会执行。简而言之**要么全部成功，要么全部失败！**



**ACID**是传统关系型数据库必须具备的标准特性。`原子性` `一致性` `隔离性` `持久性`

![image-20220926153230234](C:\Users\yanyh\AppData\Roaming\Typora\typora-user-images\image-20220926153230234.png)



### 事务隔离级别

事务隔离级别可以限制事务之间的可见性。一般来说隔离级别越低，系统的并发性越高且系统的开销也更低。不同的存储引擎对隔离级别的实现与支持也不尽相同。

**读未提交（READ UNCOMMITED）** 事务之间可以读取未提交的数据，有很多非必要的问题，在实际环境中很少使用。会出现 `脏读`

**读已提交（READ COMMITED）——RC** 是大多数数据库系统选用的隔离级别，一个事务从开始到提交前所作的任何修改对其他事务而言都是不可见的。事务在多次执行同样的查询语句时，可能会得到不一样的结果`不可重复读` 

**可重复读（REPEATABLE READ）——RR** 该隔离级别保证了同一事务在多次读取同样的记录时结果是一致的。但存在 `幻读` 的问题 ——所谓幻读是指事务在读取某个范围内的记录时，其他事务又在该范围内插入新的记录，当事务再次读取时会产生幻行的情况。

**可串行化读（SERIALIABLE）** 最高的隔离级别，强制事务串行化执行，系统的并发能力下降。可能导致大量的请求超时和锁争用或死锁的问题。

![image-20220927093902917](C:\Users\yanyh\AppData\Roaming\Typora\typora-user-images\image-20220927093902917.png)



### MVCC多版本并发控制

`乐观锁` 适合**读取频繁**的场景

`悲观锁` 适合**写入频繁**的场景



`间隙锁` 加在记录之间空闲的空间。在事务读取一个范围的数据时，InnoDB会在记录上加行锁，以及记录之间的空闲区加上间隙锁，这种做法可以解决事务的 **幻读** 。也有可能带来其他死锁的场景导致数据不能插入。

![img](https://ask.qcloudimg.com/developer-images/article-audit/8436237/0kk0okio7a.png?imageView2/2/w/1620)



![img](https://ask.qcloudimg.com/developer-images/article-audit/8436237/cwf0qi3zpr.png?imageView2/2/w/1620)

